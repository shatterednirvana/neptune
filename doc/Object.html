<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>class Object - RDoc Documentation</title>

<link type="text/css" media="screen" href="./rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
</script>

<script type="text/javascript" charset="utf-8" src="./js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="./js/darkfish.js"></script>


<body id="top" class="class">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="./index.html">Home</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  <div id="file-metadata">
    <nav id="file-list-section" class="section">
  <h3 class="section-header">Defined In</h3>
  <ul>
    <li>lib/exodus.rb
    <li>lib/babel.rb
    <li>lib/neptune_manager_client.rb
    <li>lib/neptune.rb
  </ul>
</nav>

    
  </div>

  <div id="class-metadata">
    
    <nav id="parent-class-section" class="section">
  <h3 class="section-header">Parent</h3>
  
  <p class="link">
  
</nav>

    
    <!-- Method Quickref -->
<nav id="method-list-section" class="section">
  <h3 class="section-header">Methods</h3>

  <ul class="link-list">
    
    <li><a href="#method-i-babel">#babel</a>
    
    <li><a href="#method-i-exodus">#exodus</a>
    
    <li><a href="#method-i-neptune">#neptune</a>
    
  </ul>
</nav>

  </div>

  <div id="project-metadata">
    
    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="./BabelHelper.html">BabelHelper</a>
  
    <li><a href="./BadConfigurationException.html">BadConfigurationException</a>
  
    <li><a href="./CommonFunctions.html">CommonFunctions</a>
  
    <li><a href="./ExodusHelper.html">ExodusHelper</a>
  
    <li><a href="./ExodusTaskInfo.html">ExodusTaskInfo</a>
  
    <li><a href="./FileNotFoundException.html">FileNotFoundException</a>
  
    <li><a href="./NeptuneHelper.html">NeptuneHelper</a>
  
    <li><a href="./NeptuneManagerClient.html">NeptuneManagerClient</a>
  
    <li><a href="./NeptuneManagerException.html">NeptuneManagerException</a>
  
    <li><a href="./Object.html">Object</a>
  
    <li><a href="./TaskInfo.html">TaskInfo</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation">
  <h1 class="class">class Object</h1>

  <div id="description" class="description">
    
<p>Since we’re monkeypatching <a href="Object.html">Object</a> to add
neptune() and babel(), a short blurb is necessary here to make rdoc happy.</p>

  </div><!-- description -->

  
  
  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    
    <!-- Constants -->
    <section id="constants-list" class="section">
      <h3 class="section-header">Constants</h3>
      <dl>
      
        <dt id="ALLOWED_JOB_TYPES">ALLOWED_JOB_TYPES
        
        <dd class="description"><p>A list of all the Neptune job types that we support</p>
        
      
        <dt id="ALLOWED_STORAGE_TYPES">ALLOWED_STORAGE_TYPES
        
        <dd class="description"><p>A list of storage mechanisms that we can use to store and retrieve data to
for Neptune jobs.</p>
        
      
        <dt id="DOES_NOT_EXIST">DOES_NOT_EXIST
        
        <dd class="description"><p>The constant string that a Neptune output job returns if the output does
not yet exist.</p>
        
      
        <dt id="JOB_TYPE_NOT_ALLOWED">JOB_TYPE_NOT_ALLOWED
        
        <dd class="description"><p>The string to display for disallowed job types.</p>
        
      
        <dt id="MAX_SLEEP_TIME">MAX_SLEEP_TIME
        
        <dd class="description"><p>The maximum amount of time that we should sleep to, when waiting for output
job requests.</p>
        
      
        <dt id="NEEDS_BUCKET_INFO">NEEDS_BUCKET_INFO
        
        <dd class="description"><p>If the user doesn’t give us enough info to infer what bucket we should
place their code in, this message is displayed and execution aborts.</p>
        
      
        <dt id="NEED_PREPROCESSING">NEED_PREPROCESSING
        
        <dd class="description"><p>A list of jobs that require some kind of work to be done before the actual
computation can be performed.</p>
        
      
        <dt id="NO_NODES_NEEDED">NO_NODES_NEEDED
        
        <dd class="description"><p>A list of Neptune jobs that do not require nodes to be spawned up for
computation</p>
        
      
        <dt id="NO_OUTPUT_NEEDED">NO_OUTPUT_NEEDED
        
        <dd class="description"><p>A list of Neptune jobs that do not require the output to be specified
beforehand</p>
        
      
        <dt id="NO_TIMEOUT">NO_TIMEOUT
        
        <dd class="description"><p>Sometimes SOAP calls take a long time if large amounts of data are being
sent over the network: for this first version we don’t want these calls
to endlessly timeout and retry, so as a hack, just don’t let them
timeout. The next version should replace this and properly timeout and not
use long calls unless necessary.</p>
        
      
        <dt id="SLEEP_TIME">SLEEP_TIME
        
        <dd class="description"><p>The initial amount of time, in seconds, to sleep between output job
requests. An exponential backoff is used with this value as the starting
sleep time.</p>
        
      
      </dl>
    </section>
    

    

    <!-- Methods -->
    
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section section">
      <h3 class="section-header">Public Instance Methods</h3>

    
      <div id="method-i-babel" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">babel</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Babel provides a nice wrapper around Neptune jobs. Instead of making users
write multiple Neptune jobs to actually run code (e.g., putting input in
the datastore, run the job, get the output back), Babel automatically
handles this.</p>
          

          
          <div class="method-source-code" id="babel-source">
            <pre><span class="ruby-comment"># File lib/babel.rb, line 44</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">babel</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-comment"># Since this whole function should run asynchronously, we run it as a future.</span>
  <span class="ruby-comment"># It automatically starts running in a new thread, and attempting to get the</span>
  <span class="ruby-comment"># value of what this returns causes it to block until the job completes.</span>
  <span class="ruby-comment">#future {</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Hash</span>
      <span class="ruby-identifier">was_one_job</span> = <span class="ruby-keyword">true</span>
      <span class="ruby-identifier">jobs</span> = [<span class="ruby-identifier">jobs</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">was_one_job</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-identifier">job_data_list</span> = []
    <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">params</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">job_data</span> = <span class="ruby-constant">BabelHelper</span>.<span class="ruby-identifier">convert_from_neptune_params</span>(<span class="ruby-identifier">params</span>)
      <span class="ruby-identifier">job_data</span>[<span class="ruby-string">'@metadata_info'</span>] = {<span class="ruby-string">'time_to_store_inputs'</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-value">0.0</span>}

      <span class="ruby-comment"># Add in S3 storage parameters</span>
      <span class="ruby-constant">NeptuneHelper</span>.<span class="ruby-identifier">validate_storage_params</span>(<span class="ruby-identifier">job_data</span>)

      <span class="ruby-comment"># :code is the only required parameter</span>
      <span class="ruby-comment"># everything else can use default vals</span>
      <span class="ruby-constant">NeptuneHelper</span>.<span class="ruby-identifier">require_param</span>(<span class="ruby-string">&quot;@code&quot;</span>, <span class="ruby-identifier">job_data</span>)
      <span class="ruby-constant">BabelHelper</span>.<span class="ruby-identifier">check_output_files</span>(<span class="ruby-identifier">job_data</span>)

      <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@is_remote&quot;</span>]
        <span class="ruby-comment">#BabelHelper.validate_inputs(job_data)</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-constant">BabelHelper</span>.<span class="ruby-identifier">put_code</span>(<span class="ruby-identifier">job_data</span>)
        <span class="ruby-constant">BabelHelper</span>.<span class="ruby-identifier">put_inputs</span>(<span class="ruby-identifier">job_data</span>)
      <span class="ruby-keyword">end</span>

      <span class="ruby-identifier">job_data_list</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">job_data</span>
    }

    <span class="ruby-constant">BabelHelper</span>.<span class="ruby-identifier">run_job</span>(<span class="ruby-identifier">job_data_list</span>)

    <span class="ruby-comment"># Return an object to the user that has all the information about their</span>
    <span class="ruby-comment"># task, including its standard out, err, debugging info, and profiling</span>
    <span class="ruby-comment"># info. Since the job may not be done when the user asks for this info,</span>
    <span class="ruby-comment"># its the responsibility of TaskInfo objects to block until that info</span>
    <span class="ruby-comment"># is ready. We don't explicitly return the TaskInfo object, because it's</span>
    <span class="ruby-comment"># in a Future block - it will automatically return whatever the last</span>
    <span class="ruby-comment"># statement returns.</span>
    <span class="ruby-identifier">tasks</span> = []
    <span class="ruby-identifier">job_data_list</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job_data</span><span class="ruby-operator">|</span>
      <span class="ruby-identifier">tasks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">TaskInfo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">job_data</span>)
    }

    <span class="ruby-keyword">if</span> <span class="ruby-identifier">was_one_job</span>
      <span class="ruby-identifier">tasks</span>[<span class="ruby-value">0</span>]
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">tasks</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-comment">#}</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- babel-source -->
          
        </div>

        

        
      </div><!-- babel-method -->

    
      <div id="method-i-exodus" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">exodus</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>Exodus provides further improvements to Babel. Instead of making users tell
us what compute, storage, and queue services they want to use (required for
babel calls), Exodus will automatically handle this for us. Callers need to
specify what clouds their job can run over, and Exodus will automatically
select the best cloud for their job and run it there.</p>
          

          
          <div class="method-source-code" id="exodus-source">
            <pre><span class="ruby-comment"># File lib/exodus.rb, line 20</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">exodus</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">job_given_as_hash</span> = <span class="ruby-keyword">true</span>
    <span class="ruby-identifier">jobs</span> = [<span class="ruby-identifier">jobs</span>]
  <span class="ruby-keyword">elsif</span> <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Array</span>
    <span class="ruby-identifier">job_given_as_hash</span> = <span class="ruby-keyword">false</span>
    <span class="ruby-constant">ExodusHelper</span>.<span class="ruby-identifier">ensure_all_jobs_are_hashes</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-keyword">else</span>
    <span class="ruby-identifier">raise</span> <span class="ruby-constant">BadConfigurationException</span>.<span class="ruby-identifier">new</span>(<span class="ruby-node">&quot;jobs was a #{jobs.class}, which &quot;</span> <span class="ruby-operator">+</span>
      <span class="ruby-string">&quot;is not an acceptable class type&quot;</span>)
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">tasks</span> = []

  <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">job</span><span class="ruby-operator">|</span>
    <span class="ruby-constant">ExodusHelper</span>.<span class="ruby-identifier">ensure_all_params_are_present</span>(<span class="ruby-identifier">job</span>)
    <span class="ruby-identifier">profiling_info</span> = <span class="ruby-constant">ExodusHelper</span>.<span class="ruby-identifier">get_profiling_info</span>(<span class="ruby-identifier">job</span>)
    <span class="ruby-identifier">clouds_to_run_task_on</span> = <span class="ruby-constant">ExodusHelper</span>.<span class="ruby-identifier">get_clouds_to_run_task_on</span>(<span class="ruby-identifier">job</span>, 
      <span class="ruby-identifier">profiling_info</span>)
    <span class="ruby-identifier">babel_tasks_to_run</span> = <span class="ruby-constant">ExodusHelper</span>.<span class="ruby-identifier">generate_babel_tasks</span>(<span class="ruby-identifier">job</span>, 
      <span class="ruby-identifier">clouds_to_run_task_on</span>)
    <span class="ruby-identifier">dispatched_tasks</span> = <span class="ruby-constant">ExodusHelper</span>.<span class="ruby-identifier">run_job</span>(<span class="ruby-identifier">babel_tasks_to_run</span>)
    <span class="ruby-identifier">tasks</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-constant">ExodusTaskInfo</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">dispatched_tasks</span>)
  }

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_given_as_hash</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">tasks</span>[<span class="ruby-value">0</span>]
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">tasks</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- exodus-source -->
          
        </div>

        

        
      </div><!-- exodus-method -->

    
      <div id="method-i-neptune" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">neptune</span><span
            class="method-args">(jobs)</span>
          <span class="method-click-advice">click to toggle source</span>
        </div>
        

        <div class="method-description">
          
          <p>This method is the heart of Neptune - here, we take blocks of code that the
user has written and convert them into HPC job requests. At a high level, 
the user can request to run a job, retrieve a job’s output, or modify the
access policy (ACL) for the output of a job. By default, job data is
private, but a Neptune job can be used to set it to public later (and
vice-versa).</p>
          

          
          <div class="method-source-code" id="neptune-source">
            <pre><span class="ruby-comment"># File lib/neptune.rb, line 58</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">neptune</span>(<span class="ruby-identifier">jobs</span>)
  <span class="ruby-comment"># Kernel.puts &quot;Received a request to run a job.&quot;</span>
  <span class="ruby-comment"># Kernel.puts params[:type]</span>
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">class</span> <span class="ruby-operator">==</span> <span class="ruby-constant">Hash</span>
    <span class="ruby-identifier">jobs</span> = [<span class="ruby-identifier">jobs</span>]
  <span class="ruby-keyword">end</span>

  <span class="ruby-identifier">job_data_list</span> = []
  <span class="ruby-identifier">shadow_ip</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">ssh_args</span> = <span class="ruby-string">&quot;&quot;</span>
  <span class="ruby-identifier">secret</span> = <span class="ruby-string">&quot;&quot;</span>
  <span class="ruby-identifier">controller</span> = <span class="ruby-keyword">nil</span>

  <span class="ruby-identifier">jobs</span>.<span class="ruby-identifier">each</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">params</span><span class="ruby-operator">|</span>
    <span class="ruby-identifier">job_data</span> = <span class="ruby-constant">NeptuneHelper</span>.<span class="ruby-identifier">get_job_data</span>(<span class="ruby-identifier">params</span>)
    <span class="ruby-constant">NeptuneHelper</span>.<span class="ruby-identifier">validate_storage_params</span>(<span class="ruby-identifier">job_data</span>)
    <span class="ruby-comment"># Kernel.puts &quot;job data = #{job_data.inspect}&quot;</span>
    <span class="ruby-identifier">keyname</span> = <span class="ruby-identifier">job_data</span>[<span class="ruby-string">&quot;@keyname&quot;</span>]

    <span class="ruby-identifier">shadow_ip</span> = <span class="ruby-constant">CommonFunctions</span>.<span class="ruby-identifier">get_from_yaml</span>(<span class="ruby-identifier">keyname</span>, <span class="ruby-value">:shadow</span>)
    <span class="ruby-identifier">secret</span> = <span class="ruby-constant">CommonFunctions</span>.<span class="ruby-identifier">get_secret_key</span>(<span class="ruby-identifier">keyname</span>)
    <span class="ruby-identifier">ssh_key</span> = <span class="ruby-constant">File</span>.<span class="ruby-identifier">expand_path</span>(<span class="ruby-node">&quot;~/.appscale/#{keyname}.key&quot;</span>)
    <span class="ruby-identifier">ssh_args</span> = <span class="ruby-node">&quot;-i ~/.appscale/#{keyname}.key -o StrictHostkeyChecking=no &quot;</span>

    <span class="ruby-identifier">controller</span> = <span class="ruby-constant">NeptuneManagerClient</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">shadow_ip</span>, <span class="ruby-identifier">secret</span>)
    <span class="ruby-constant">NeptuneHelper</span>.<span class="ruby-identifier">do_preprocessing</span>(<span class="ruby-identifier">job_data</span>, <span class="ruby-identifier">controller</span>)
    <span class="ruby-identifier">job_data_list</span> <span class="ruby-operator">&lt;&lt;</span> <span class="ruby-identifier">job_data</span>
  }

  <span class="ruby-keyword">if</span> <span class="ruby-identifier">job_data_list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">==</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">return</span> <span class="ruby-constant">NeptuneHelper</span>.<span class="ruby-identifier">run_job</span>(<span class="ruby-identifier">job_data_list</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">ssh_args</span>, <span class="ruby-identifier">shadow_ip</span>, 
      <span class="ruby-identifier">secret</span>)
  <span class="ruby-keyword">else</span>  <span class="ruby-comment"># right now we only support batch run_job operations</span>
    <span class="ruby-identifier">msg</span> = <span class="ruby-identifier">controller</span>.<span class="ruby-identifier">start_neptune_job</span>(<span class="ruby-identifier">job_data_list</span>)
    <span class="ruby-identifier">result</span> = {}
    <span class="ruby-identifier">result</span>[<span class="ruby-value">:msg</span>] = <span class="ruby-identifier">msg</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span>[<span class="ruby-value">:msg</span>] <span class="ruby-operator">=~</span> <span class="ruby-regexp">%rjob is now running\Z/</span>
      <span class="ruby-identifier">result</span>[<span class="ruby-value">:result</span>] = <span class="ruby-value">:success</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">result</span>[<span class="ruby-value">:result</span>] = <span class="ruby-value">:failure</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">return</span> <span class="ruby-identifier">result</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
          </div><!-- neptune-source -->
          
        </div>

        

        
      </div><!-- neptune-method -->

    
    </section><!-- public-instance-method-details -->
  
  </section><!-- 5Buntitled-5D -->

</div><!-- documentation -->


<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 3.12.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

